

glob_trivial(string) ::= <<
return input_string.equals("<string>");
>>

glob_without_star(pattern_length, char_classes) ::= <<
const long pattern_length = pattern.length();
long i = 0;
<expect_length_equal_to(pattern_length)>
<char_classes:{char_class |<(char_class.type)(char_class)>}>
return true;
>>

glob_with_star(pattern_length) ::= <<
const long input_length = input_string.length();
<expect_length_greater_than(pattern_length)>
<char_classes:{char_class |<(char_class.type)(char_class)>}>
return true;
>>


char(node) ::= <<
if (<mismatched_char(node.char)>) {
    return false;
}
<next_char()>
>>

mismatched_char(char) ::= <<input_string.charAt(i) != '<char>'>>
matched_char(char) ::= <<input_string.charAt(i) == '<char>'>>

any_char(node) ::= <<
if (<mismatched_any_char(node)>) {
    return false;
}
<next_char()>
>>
matched_any_char(node) ::= "<not_eos()>"
mismatched_any_char(node) ::= "<eos()>"

character_class(node) ::= <<
if (<mismatched_character_class(node)>) {
    return false;
}
<next_char()>
>>
matched_character_class(node) ::= <<<node.chars:matched_char(); anchor, separator="\n || ">>>
mismatched_character_class(node) ::= <<<node.chars:mismatched_char(); anchor, separator="\n && ">>>

negated_character_class(node) ::= <<
if (<mismatched_negated_character_class(node)>) {
    return false;
}
<next_char()>
>>
matched_negated_character_class(node) ::= matched_character_class(node)
mismatched_negated_character_class(node) ::= mismatched_character_class(node)

star(node) ::= <<
while (<not_eos()> ) {
    <node.next:{next|<(next.type)(next)>}>
    <next_char()>;
}
>>

next_char() ::= <<
i++;
>>

eos() ::= <<i >= input_length>>
not_eos() ::= <<i < input_length>>

expect_length_equal_to(pattern_length) ::= <<
if (input_length != <pattern_length>) {
    return false;
}
>>

expect_length_greater_than(pattern_length) ::= <<
if (input_length < <pattern_length>) {
    return false;
}
>>